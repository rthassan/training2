/*
     * Your installation or use of this SugarCRM file is subject to the applicable
     * terms available at
     * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
     * If you do not agree to all of the applicable terms or do not have the
     * authority to bind the entity as an authorized representative, then do not
     * install or use this SugarCRM file.
     *
     * Copyright (C) SugarCRM Inc. All rights reserved.
     *//*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    /**
     * Backwards compatibility (Bwc) class manages all required methods for BWC
     * modules.
     *
     * A BWC module is defined in the metadata by the `isBwcEnabled` property.
     *
     * @class Sugar.Bwc
     * @singleton
     * @alias SUGAR.App.bwc
     */
    var Bwc = {
        /**
         * Performs backward compatibility login.
         *
         * The OAuth token is passed and we do automatic in bwc mode by
         * getting a cookie with the PHPSESSIONID.
         */

        /**
         * Logs into sugar in BWC mode. Allows for use of current OAuth token as
         * a session id for backward compatible modules.
         * 
         * @param  {String} redirectUrl A URL to redirect to after logging in
         * @param  {Function} callback A function to call after logging in
         * @return {Void}
         */
        login: function(redirectUrl, callback) {
            var url = app.api.buildURL('oauth2', 'bwc/login');
            return app.api.call('create', url, {}, {
                success: function(data) {
                    // Set the session name into the cache so that certain bwc
                    // modules can access it as needed (studio)
                    if (data && data.name) {
                        app.cache.set("SessionName", data.name);
                    }

                    // If there was a callback, call it. This will almost always
                    // be used exlusively by studio when trying to refresh the 
                    // session after it expires.
                    if (callback) {
                        callback();
                    }

                    // If there was a redirectUrl passed, go there. This will 
                    // almost always be the case, except in studio when a login
                    // is simply updating the session id
                    if (redirectUrl) {
                        app.router.navigate('#bwc/' + redirectUrl, {trigger: true});
                    }
                }
            });
        },

        /**
         * Translates an action to a BWC action.
         *
         * If the action wasn't found to be translated, the given action is
         * returned.
         *
         * @param {String} action The action to translate to a BWC one.
         * @return {String} The BWC equivalent action.
         */
        getAction: function(action) {
            var bwcActions = {
                'create': 'EditView',
                'edit': 'EditView',
                'detail': 'DetailView'
            };

            return bwcActions[action] || action;
        },

        /**
         * Builds a backwards compatible route. For example:
         * bwc/index.php?module=MyModule&action=DetailView&record12345
         *
         * @param {String} module The name of the module.
         * @param {String} [id] The model's ID.
         * @param {String} [action] Backwards compatible action name.
         * @param {Object} [params] Extra params to be sent on the bwc link.
         * @return {String} The built route.
         */
        buildRoute: function(module, id, action, params) {

            /**
             * app.bwc.buildRoute is for internal use and we control its callers, so we're
             * assuming callers will provide the module param which is marked required!
             */
            var href = 'bwc/index.php?',
                params = _.extend({}, { module: module }, params);

            if (!action && !id || action==='DetailView' && !id) {
                params.action = 'index';
            } else {
                if (action) {
                    params.action = action;
                } else {
                    //no action but we do have id
                    params.action = 'DetailView';
                }
                if (id) {
                    params.record = id;
                }
            }
            return href + $.param(params);
        },
        /**
         * For BWC modules, we need to get URL params for creating the related record
         * @returns {Object} BWC URL parameters
         * @private
         */
        _createRelatedRecordUrlParams: function(parentModel, link) {
            var params = {
                parent_type: parentModel.module,
                parent_name: parentModel.get('name') || parentModel.get('full_name'),
                parent_id: parentModel.get("id"),
                return_module: parentModel.module,
                return_id: parentModel.get("id"),
                return_name: parentModel.get('name') || parentModel.get('full_name')
            };

            // find relationship name
            var linkField = _.find(parentModel.fields, function(field) {
                return (field.type == 'link' && field.name == link)
            });

            if (linkField) {
                params['return_relationship'] = linkField.relationship;
            }

            //Handle special cases
            params = this._handleRelatedRecordSpecialCases(params, parentModel, link);

            //Set relate field values as part of URL so they get pre-filled
            var fields = app.data.getRelateFields(parentModel.module, link);
            _.each(fields, function(field){
                params[field.name] = parentModel.get(field.rname);
                params[field.id_name] = parentModel.get("id");
                if(field.populate_list) {
                    // We need to populate fields from parent record into new related record
                    _.each(field.populate_list, function (target, source) {
                        source = _.isNumber(source) ? target : source;
                        if (!_.isUndefined(parentModel.get(source))) {
                            params[target] = parentModel.get(source);
                        }
                    }, this);
                }
            });
            return params;
        },
        /**
         * Handles special cases when building the related record URL.
         * @return {Object} BWC URL parameters taking edge cases in to consideration
         * @private
         */
        _handleRelatedRecordSpecialCases: function(params, parentModel, link) {
            // We should pull the value from the syncedAttributes as they are what comes back from the server on load
            // and after a save.  The reason for this is the following use case.
            // On an opportunity, change the account but *don't save* and then press the + button on the quote subpanel
            // it will take the unsaved value and use it when creating the quote, if you press confirm to the
            // "Are you sure" dialog.  By using the syncedAttributes, it won't take any unsaved values,
            // but on the off chance that the value doesn't exist in the synced attributes, it will fall back to the
            // parentModel
            var syncedAttributes = parentModel.getSyncedAttributes();
            //Special case for Contacts->meetings. The parent should be the account rather than the contact
            if (parentModel.module == 'Contacts' &&
                    parentModel.has('account_id') &&
                    (link == 'meetings' || link == 'calls')
                ) {
                params = _.extend(params, {
                    parent_type: 'Accounts',
                    parent_id: syncedAttributes.account_id || parentModel.get('account_id'),
                    account_id: syncedAttributes.account_id || parentModel.get('account_id'),
                    account_name: syncedAttributes.account_name || parentModel.get('account_name'),
                    parent_name: syncedAttributes.account_name || parentModel.get('account_name'),
                    contact_id: syncedAttributes.id || parentModel.get('id'),
                    contact_name: syncedAttributes.full_name || parentModel.get('full_name')
                });
            }
            //SP-1600: Account information is not populated during Quote creation via Opportunity Quote Subpanel
            // any time we link to quotes and we have an account_id, we should always populate it.
            if (link == 'quotes' || link == 'contracts') {
                if (parentModel.has('account_id')) {
                    //Note that the bwc view will automagically give us billing/shipping and only
                    //expects us to set account_id and account_name here
                    params = _.extend(params, {
                        account_id: syncedAttributes.account_id || parentModel.get('account_id'),
                        account_name: syncedAttributes.account_name || parentModel.get('account_name')
                    });
                }

                if (parentModel.module === 'Contacts') {
                    // if we are coming from the contacts module, we need to get the id and set it
                    // we don't need the syncedAttribute here as id will never change on the front end.
                    params = _.extend(params, {
                        contact_id: parentModel.get('id')
                    });
                } else if (parentModel.has('contact_id')) {
                    params = _.extend(params, {
                        contact_id: syncedAttributes.contact_id || parentModel.get('contact_id')
                    });
                }
            }
            return params;
        },

        /**
         * Route to Create Related record UI for a BWC module
         */
        createRelatedRecord: function(module, parentModel, link, id) {
            var params = this._createRelatedRecordUrlParams(parentModel, link);
            var route = app.bwc.buildRoute(module, id || null, "EditView", params);
            app.router.navigate("#" + route, {trigger: true}); // Set route so that we switch over to BWC mode
        },

        /**
         * Enables the ability to share a record from a BWC module.
         *
         * This will trigger the sharing action already defined in the
         * {@link BaseShareactionField#share()}.
         *
         * @param {String} module The module that we are sharing.
         * @param {String} id The record id that we are sharing.
         * @param {String} name The record name that we are sharing.
         */
        shareRecord: function(module, id, name) {
            var shareField = app.view.createField({
                    def: {
                        type: 'shareaction'
                    },
                    module: module,
                    model: app.data.createBean(module, {
                        id: id,
                        name: name
                    }),
                    view: app.view.createView({})
                });

            if (shareField.useSugarEmailClient()) {
                shareField.shareWithSugarEmailClient();
            } else {
                this._launchExternalEmail(shareField.getShareMailtoUrl());
            }
        },

        /**
         * Launch a mailto via javascript
         * Yes, this is a hack, but strategically placed in BWC so it will go away.
         * If you have a better solution, please fix this.
         * Note: doing window.location.href = 'mailto:'; window.close(); has timing problems.
         * Also, reworking Smarty sugar_button function code has its own set of challenges.
         *
         * @param mailto
         * @private
         */
        _launchExternalEmail: function(mailto) {
            var tempMailTo = $('<a href="' + mailto + '"></a>').appendTo('body');
            tempMailTo.get(0).click();
            tempMailTo.remove();
        },

        /**
         * Revert bwc model attributes in order to skip warning unsaved changes.
         */
        revertAttributes: function() {
            var view = app.controller.layout.getComponent('bwc');
            if (!view) {
                return;
            }
            view.revertBwcModel();
        }
    };
    app.augment('bwc', _.extend(Bwc, Backbone.Events), false);
})(SUGAR.App);

/* End of File include/javascript/sugar7/bwc.js */

/*
     * Your installation or use of this SugarCRM file is subject to the applicable
     * terms available at
     * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
     * If you do not agree to all of the applicable terms or do not have the
     * authority to bind the entity as an authorized representative, then do not
     * install or use this SugarCRM file.
     *
     * Copyright (C) SugarCRM Inc. All rights reserved.
     *//*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on("app:init", function() {
        app.utils = _.extend(app.utils, {
            tooltip: {
                /**
                 * Initializes tooltips for given elements
                 * @param {jQuery} $elements
                 * @param {object} (optional) options - see bootstrap-tooltip docs
                 * @returns {jQuery}
                 */
                initialize: function($elements, options) {
                    options = options || {};
                    var self = this;
                    $elements.each(function() {
                        var data, $element;
                        if (!self.has(this)) {
                            $element = $(this);
                            data = $element.data();

                            //Override the tooltip template to have a `dir`
                            //attribute if it is present in the element.
                            var dir = $element.attr('dir'),
                                tooltipTemplate = Handlebars.compile('<div class="tooltip"' +
                                    '{{#if dir}} dir="{{dir}}"{{/if}}' +
                                    '><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>');
                            options.template = tooltipTemplate({dir: dir});

                            $element.tooltip(_.extend({
                                container: 'body',
                                trigger: 'hover' //show tooltip on hover only (not on focus)
                            }, data, options));
                        }
                    });
                    return $elements;
                },

                /**
                 * Destroy tooltips
                 * @param {jQuery} $tooltips
                 */
                destroy: function($tooltips) {
                    if ($tooltips) {
                        _.each($tooltips, function(tooltip) {
                            var plugin;
                            if (this.has(tooltip)) {
                                plugin = this.get(tooltip);
                                plugin.leave(plugin); //need to call leave() first because of a bug in tooltip v3
                                plugin.destroy();
                            }
                        }, this);
                    }
                },

                /**
                 * Show tooltip.
                 * @param {DOM} element
                 */
                show: function(element) {
                    var plugin;
                    if (this.has(element)) {
                        plugin = this.get(element);
                        plugin.enter(plugin); //need to use enter() instead of show() because of a bug in tooltip v3
                    }
                },

                /**
                 * Hide tooltip.
                 * @param {DOM} element
                 */
                hide: function(element) {
                    var plugin;
                    if (this.has(element)) {
                        plugin = this.get(element);
                        plugin.leave(plugin); //need to use leave() instead of hide() because of a bug in tooltip v3
                    }
                },

                /**
                 * Does the given element have tooltip?
                 * @param {DOM} element
                 * @returns {boolean}
                 */
                has: function(element) {
                    return !_.isUndefined(this.get(element));
                },

                /**
                 * Get the tooltip plugin for this given element.
                 * @param {DOM} element
                 * @returns {tooltip}
                 */
                get: function(element) {
                    return $(element).data('bs.tooltip');
                }
            },

            /**
             * Takes two Forecasts models and returns HTML for the history log
             *
             * @param oldestModel {Backbone.Model} the oldest model by date_entered
             * @param newestModel {Backbone.Model} the most recent model by date_entered
             * @return {Object}
             */
            createHistoryLog: function(oldestModel, newestModel) {
                var is_first_commit = false;

                if(_.isEmpty(oldestModel)) {
                    oldestModel = new Backbone.Model({
                        best_case: 0,
                        likely_case: 0,
                        worst_case: 0,
                        date_entered: ''
                    });
                    is_first_commit = true;
                }
                var best_difference = this.getDifference(oldestModel, newestModel, 'best_case'),
                    best_direction = this.getDirection(best_difference),
                    likely_difference = this.getDifference(oldestModel, newestModel, 'likely_case'),
                    likely_direction = this.getDirection(likely_difference),
                    worst_difference = this.getDifference(oldestModel, newestModel, 'worst_case'),
                    worst_direction = this.getDirection(worst_difference),
                    args = [],
                    best_arrow = this.getArrowDirectionSpan(best_direction),
                    likely_arrow = this.getArrowDirectionSpan(likely_direction),
                    worst_arrow = this.getArrowDirectionSpan(worst_direction),
                    num_shown = 0,
                    hb = Handlebars.compile("{{{str key module args}}}"),
                    lang_string_key = '',
                    final_args = [],
                    labels = [],
                    config = app.metadata.getModule('Forecasts', 'config'),
                    likely_args = {
                        changed: likely_difference != 0,
                        show: config.show_worksheet_likely
                    },
                    best_args = {
                        changed: best_difference != 0,
                        show: config.show_worksheet_best
                    },
                    worst_args = {
                        changed: worst_difference != 0,
                        show: config.show_worksheet_worst
                    };

                // increment num_shown for each variable that is true
                likely_args.show ? num_shown++ : '';
                best_args.show ? num_shown++ : '';
                worst_args.show ? num_shown++ : '';

                // set the key for the lang string
                lang_string_key = 'LBL_COMMITTED_HISTORY_' + num_shown + '_SHOWN';

                if(worst_args.changed && worst_args.show) {
                    final_args.push(
                        this.gatherLangArgsByParams(
                            worst_direction,
                            worst_arrow,
                            worst_difference,
                            newestModel,
                            'worst_case'
                        )
                    );
                } else if(worst_args.show) {
                    // push an empty array for args
                    final_args.push([]);
                }

                //determine what changed and add parts to the array for displaying the changes
                if(likely_args.changed && likely_args.show) {
                    final_args.push(
                        this.gatherLangArgsByParams(
                            likely_direction,
                            likely_arrow,
                            likely_difference,
                            newestModel,
                            'likely_case'
                        )
                    );
                } else if(likely_args.show) {
                    // push an empty array for args
                    final_args.push([]);
                }

                if(best_args.changed && best_args.show) {
                    final_args.push(
                        this.gatherLangArgsByParams(
                            best_direction,
                            best_arrow,
                            best_difference,
                            newestModel,
                            'best_case'
                        )
                    );
                } else if(best_args.show) {
                    // push an empty array for args
                    final_args.push([]);
                }

                // get the final args to go into the main text
                labels = this.getCommittedHistoryLabel(best_args, likely_args, worst_args, is_first_commit);

                final_args = this.parseArgsAndLabels(final_args, labels);

                //Compile the language string for the log
                var text = hb({'key': lang_string_key, 'module': "Forecasts", 'args': final_args});

                // need to tell Handelbars not to escape the string when it renders it, since there might be
                // html in the string, args returned for testing purposes
                return {'text': new Handlebars.SafeString(text)};
            },

            /**
             * Returns an array of three args for the html for the arrow,
             * the difference (amount changed), and the new value
             *
             * @param dir {String} direction of the arrow, LBL_UP/LBL_DOWN
             * @param arrow {String} HTML for the arrow string
             * @param diff {Number} difference between the new model and old model
             * @param model {Backbone.Model} the newestModel being used so we can get the current caseStr
             * @param attrStr {String} the attr string to get from the newest model
             */
            gatherLangArgsByParams: function(dir, arrow, diff, model, attrStr) {
                return {
                    'direction' : new Handlebars.SafeString(app.lang.get(dir, 'Forecasts') + arrow),
                    'from' :app.currency.formatAmountLocale(Math.abs(diff)),
                    'to' : app.currency.formatAmountLocale(model.get(attrStr))
                };
            },

            /**
             * checks the direction class passed in to determine what span to create to show the appropriate arrow
             * or lack of arrow to display on the
             * @param directionClass class being used for the label ('LBL_UP' or 'LBL_DOWN')
             * @return {String}
             */
            getArrowDirectionSpan: function(directionClass) {
                return directionClass == "LBL_UP" ? '&nbsp;<i class="fa fa-arrow-up font-green"></i>' :
                    directionClass == "LBL_DOWN" ? '&nbsp;<i class="fa fa-arrow-down font-red"></i>' : '';
            },

            /**
             * Centralizes our forecast type switch.
             *
             * @param isManager
             * @param showOpps
             * @return {String} 'Direct' or 'Rollup'
             */
            getForecastType: function(isManager, showOpps) {
                /**
                 * Three cases exist when a row is showing commitLog icon:
                 *
                 * Manager - showOpps=1 - isManager=1 => Mgr's Opportunities row - forecast_type = 'Direct'
                 * Manager - showOpps=0 - isManager=1 => Mgr has another mgr in their MgrWkst - forecast_type = 'Rollup'
                 * Rep     - showOpps=0 - isManager=0 => Sales Rep (not a manager) row - forecast_type = 'Direct'
                 */
                return (!showOpps && isManager) ? 'Rollup' : 'Direct';
            },

            /**
             * builds the args to look up for the history label based on what has changed in the model
             * @param best {Object}
             * @param likely {Object}
             * @param worst {Object}
             * @param is_first_commit {bool}
             * @return {Array}
             */
            getCommittedHistoryLabel: function(best, likely, worst, is_first_commit) {
                var args = [];

                // Handle if this is the first commit
                if(is_first_commit) {
                    args.push('LBL_COMMITTED_HISTORY_SETUP_FORECAST');
                } else {
                    args.push('LBL_COMMITTED_HISTORY_UPDATED_FORECAST');
                }

                // Handle Worst
                if(worst.show) {
                    if(worst.changed) {
                        args.push('LBL_COMMITTED_HISTORY_WORST_CHANGED');
                    } else {
                        args.push('LBL_COMMITTED_HISTORY_WORST_SAME');
                    }
                }

                // Handle Likely
                if(likely.show) {
                    if(likely.changed) {
                        args.push('LBL_COMMITTED_HISTORY_LIKELY_CHANGED');
                    } else {
                        args.push('LBL_COMMITTED_HISTORY_LIKELY_SAME');
                    }
                }

                // Handle Best
                if(best.show) {
                    if(best.changed) {
                        args.push('LBL_COMMITTED_HISTORY_BEST_CHANGED');
                    } else {
                        args.push('LBL_COMMITTED_HISTORY_BEST_SAME');
                    }
                }

                return args;
            },

            /**
             * Parses through labels array and adds the proper args in to the string
             *
             * @param argsArray {Array} of args (direction arrow html, amount difference and the new amount)
             * @param labels {Array} of lang key labels to use
             * @return {Array}
             */
            parseArgsAndLabels: function(argsArray, labels) {
                var retArgs = {},
                    argsKeys = ['first', 'second', 'third'],
                    hb = Handlebars.compile("{{{str key module args}}}");

                // labels should have one more item in its array than argsArray
                // because of the SETUP or UPDATED label which has no args
                if((argsArray.length + 1) != labels.length) {
                    // SOMETHING CRAAAAZY HAPPENED!
                    var msg = 'ForecastsUtils.parseArgsAndLabels() :: '
                            + 'argsArray and labels params are not the same length';
                    app.logger.error(msg);
                    return null;
                }

                // get the first argument off the label array
                retArgs.intro = hb({'key': _.first(labels), 'module': 'Forecasts', 'args': []});

                // get the other values, with out the first value
                labels = _.last(labels, labels.length - 1);

                // loop though all the other values
                _.each(labels, function(label, index) {
                    retArgs[argsKeys[index]] = hb({'key': label, 'module': 'Forecasts', 'args': argsArray[index]});
                });

                return retArgs;
            },

            /**
             * Returns the difference between the newest model and the oldest
             *
             * @param oldModel {Backbone.Model}
             * @param newModel {Backbone.Model}
             * @param attr {String} the attribute key to get from the models
             * @return {*}
             */
            getDifference: function(oldModel, newModel, attr) {
                return (app.math.isDifferentWithPrecision(newModel.get(attr), oldModel.get(attr))) ?
                    app.math.getDifference(newModel.get(attr), oldModel.get(attr)) : 0;
            },


            /**
             * Returns the proper direction label to use
             *
             * @param difference the amount of difference between newest and oldest models
             * @return {String} LBL_UP, LBL_DOWN, or ''
             */
            getDirection: function(difference) {
                return difference > 0 ? 'LBL_UP' : (difference < 0 ? 'LBL_DOWN' : '');
            },

            /**
             * Returns the subpanel list with link module name and corresponding LBL_
             *
             * @param module
             * @return {Object} The subpanel list
             */
            getSubpanelList: function(module) {
                var list = {},
                    subpanels = app.metadata.getModule(module);
                if (subpanels && subpanels.layouts) {
                    subpanels = subpanels.layouts.subpanels;
                    if (subpanels && subpanels.meta && subpanels.meta.components) {
                        _.each(subpanels.meta.components, function(comp) {
                            if (comp.context && comp.context.link) {
                                list[comp.label] = comp.context.link;
                            } else {
                                app.logger.warning("Subpanel's subpanels.meta.components "
                                    + "has component with no context or context.link");
                            }
                        });
                    }
                }
                return list;
            },

            /**
             * Returns TRUE if any of the related fields associated with this link are required,
             * which would make this link required.  Returns FALSE otherwise.
             *
             * @param {String} module Parent module name
             * @param {String} link Link name
             * @return {Boolean}
             */
            isRequiredLink: function(module, link){
                var relatedFields = app.data.getRelateFields(module, link),
                    requiredField = _.some(relatedFields, function(field){
                        return field.required === true;
                    }, this);
                return requiredField;
            },

            /**
             * Contains a list of column names from metadata and maps them to correct config param
             * e.g. 'likely_case' column is controlled by the Forecast config.show_worksheet_likely param
             * Used by forecastsWorksheetManager, forecastsWorksheetManagerTotals
             *
             * @property tableColumnsConfigKeyMapManager
             * @private
             */
            _tableColumnsConfigKeyMapManager: {
                'likely_case': 'show_worksheet_likely',
                'likely_case_adjusted': 'show_worksheet_likely',
                'best_case': 'show_worksheet_best',
                'best_case_adjusted': 'show_worksheet_best',
                'worst_case': 'show_worksheet_worst',
                'worst_case_adjusted': 'show_worksheet_worst'
            },

            /**
             * Contains a list of column names from metadata and maps them to correct config param
             * e.g. 'likely_case' column is controlled by the Forecast config.show_worksheet_likely param
             * Used by forecastsWorksheet, forecastsWorksheetTotals
             *
             * @property tableColumnsConfigKeyMapRep
             * @private
             */
            _tableColumnsConfigKeyMapRep: {
                'likely_case': 'show_worksheet_likely',
                'best_case': 'show_worksheet_best',
                'worst_case': 'show_worksheet_worst'
            },

            /**
             * Function checks the proper _tableColumnsConfigKeyMap___ for the key and returns the config setting
             *
             * @param key {String} table key name (eg: 'likely_case')
             * @param viewName {String} the name of the view calling the function (eg: 'forecastsWorksheet')
             * @return {*}
             */
            getColumnVisFromKeyMap: function(key, viewName) {
                var moduleMap = {
                        'forecastsWorksheet': 'rep',
                        'forecastsWorksheetTotals': 'rep',
                        'forecastsWorksheetManager': 'mgr',
                        'forecastsWorksheetManagerTotals': 'mgr'
                    },
                    whichKeyMap,
                    keyMap,
                    returnValue;

                // which key map to use from the moduleMap
                whichKeyMap = moduleMap[viewName];

                // get the proper keymap
                keyMap = (whichKeyMap === 'rep') ? this._tableColumnsConfigKeyMapRep
                                                 : this._tableColumnsConfigKeyMapManager;

                returnValue = app.metadata.getModule('Forecasts', 'config')[keyMap[key]];
                // If we've been passed a value that doesn't exist in the keymaps
                if(!_.isUndefined(returnValue)) {
                    // convert it to boolean
                    returnValue = returnValue == 1
                } else {
                    // if return value was null (not found) then set to true
                    returnValue = true;
                }
                return returnValue;
            },

            /**
             * If the passed in User is a Manager, then get his direct reportees, and then set the user
             * on the context, if they are not a Manager, just set user to the context
             * @param selectedUser
             * @param context
             */
            getSelectedUsersReportees: function(selectedUser, context) {
                if(selectedUser.is_manager) {
                    // make sure the reportee's array is there
                    if(_.isUndefined(selectedUser.reportees)) {
                        selectedUser.reportees = [];
                    }
                    var url = app.api.buildURL('Users', 'filter'),
                        post_args = {
                            "filter": [
                                {
                                    'reports_to_id': selectedUser.id,
                                    'status' : 'Active'
                                }
                            ],
                            'fields': 'full_name',
                            'max_num': 1000
                        },
                        options = {};
                    options.success = _.bind(function(resp, status, xhr) {
                        _.each(resp.records, function(user) {
                            selectedUser.reportees.push({id: user.id, name: user.full_name});
                        });
                        this.set("selectedUser", selectedUser)
                    }, context);
                    app.api.call("create", url, post_args, options);
                } else {
                    // update context with selected user which will trigger checkRender
                    context.set("selectedUser", selectedUser);
                }
            },

            /**
             * Makes sure that Sales Stage Won/Lost values from the database Forecasts config settings
             * exist in the sales_stage_dom
             *
             * @returns {Boolean} if forecasts is configured to run ok
             */
            checkForecastConfig: function() {
                var forecastConfigOK = true,
                    cfg = app.metadata.getModule('Forecasts', 'config') || {},
                    salesWonVals = cfg.sales_stage_won,
                    salesLostVals = cfg.sales_stage_lost,
                    salesWonLostVals = cfg.sales_stage_won.concat(cfg.sales_stage_lost),
                    domVals = app.lang.getAppListStrings('sales_stage_dom');

                if(salesWonVals.length == 0 || salesLostVals.length == 0 || _.isEmpty(domVals)) {
                    forecastConfigOK = false;
                } else {
                    forecastConfigOK = _.every(salesWonLostVals, function(val) {
                        return (val != '' && _.has(domVals, val));
                    }, this);
                }

                return forecastConfigOK;
            },

            /**
             * Returns if the current browser has touch events
             *
             * @returns {Boolean}
             */
            isTouchDevice: function() {
                return Modernizr.touch;
            },

            /**
             * Builds a route for module in either bwc or new sidecar.
             *
             * This overrides the normal router to check first if the module
             * is in BWC or not. If not, this will fallback to default
             * {@link Core.Routing#buildRoute}.
             *
             * {@inheritDoc}
             * @param {Boolean} inBwc If `true` it will force bwc, if `false`
             * it will force sidecar, if not defined, will use metadata
             * information on module. This is a temporary param (hack) and will
             * be removed after we change all the views/layouts to be the ones
             * pointing if it should be loaded in BWC or not.
             *
             * @override Core.Routing#buildRoute
             * @see Bwc#buildRoute()
             */
            customBuildRoute: function(moduleOrContext, id, action, inBwc) {
                var module, moduleMeta;

                // Since _.isString(undefined) returns false,
                // the following block prevent going getter block
                if (_.isEmpty(moduleOrContext)) {
                    return '';
                }

                if (_.isString(moduleOrContext)) {
                    module = moduleOrContext;
                } else {
                    module = moduleOrContext.get('module');
                }

                if (_.isEmpty(module) || !app.bwc) {
                    return '';
                }

                moduleMeta = app.metadata.getModule(module) || {};
                if (inBwc === false || (_.isUndefined(inBwc) && !moduleMeta.isBwcEnabled)) {
                    return '';
                }

                return app.bwc.buildRoute(module, id, app.bwc.getAction(action));
            },

            /**
             * Adds `bwcFrame=1` to the URL if it's not there.
             *
             * @param {string} url The original url.
             * @return {string} The url with the iframe mark.
             */
            addIframeMark: function(url) {
                var parts = url.split('?');
                if (parts[1] && parts[1].indexOf('bwcFrame=1') != -1) return url;
                return parts[0] + '?' + (parts[1] ? parts[1] + '&bwcFrame=1' : 'bwcFrame=1');
            },

            /**
             * Removes `bwcFrame=1` from the URL if it's there.
             *
             * @param {string} url The original url.
             * @return {string} The url without the iframe mark.
             */
            rmIframeMark: function(url) {
                var parts = url.split('?');
                if (!parts[1]) {
                    return url;
                }
                // scan and drop bwcFrame=1
                return parts[0] + '?' + _.reduce(parts[1].split('&'), function(acc, item) {
                    if (item == 'bwcFrame=1') {
                        return acc;
                    } else {
                        return acc ? acc + '&' + item : item;
                    }
                }, '');
            },

            /**
             * Returns a collection of subpanel models from the LHS context
             * Only tested in Record View!
             *
             * @param ctx the LHS context
             * @param {String} module the name of the module to look for
             * @returns {*} returns the collection or undefined
             */
            getSubpanelCollection: function(ctx, module) {
                var retCollection = undefined,
                    mdl = _.find(ctx.children, function(child) {
                        return (child.get('module') == module);
                    });
                if(mdl && _.has(mdl.attributes, 'collection')) {
                    retCollection = mdl.get('collection');
                }

                return retCollection;
            },
            /**
             * Extracts the full record name from a model.
             *
             * @param {Data.Bean} model The model concerned.
             * @return {string} The record name.
             */
            getRecordName: function(model) {
                // Special case for `Documents`
                if (model.module === 'Documents' && model.has('document_name')) {
                    return model.get('document_name');

                // Special case for `Person` type modules
                } else if (model.has('full_name')) {
                    return model.get('full_name');

                // Special case for `Person` type modules
                } else if (model.has('first_name') && model.has('last_name')) {
                    return model.get('first_name') + ' ' + model.get('last_name');

                // Default behavior
                } else {
                    return model.get('name') || '';
                }
            },

            /**
             * Resolve data conflict on bean update. Open a drawer to pick between data in the database
             * or the data currently in the bean.
             * @param error
             * @param model
             * @param callback
             */
            resolve409Conflict: function(error, model, callback) {
                app.drawer.open({
                    layout: 'resolve-conflicts',
                    context: {
                        dataInDb: error.payload.record,
                        modelToSave: model
                    }
                }, callback);
            },

            /**
             * Returns the Forecasts not setup message with link to config if isAdmin is true
             *
             * @param {boolean} isAdmin is the user an admin
             * @returns {string} a translated string with a link to Forecasts config if user is an admin
             */
            getForecastNotSetUpMessage: function(isAdmin) {
                var langKey = (isAdmin) ? 'LBL_DASHLET_FORECAST_NOT_SETUP_ADMIN' : 'LBL_DASHLET_FORECAST_NOT_SETUP',
                    msg = app.lang.get(langKey, 'Forecasts');
                if(isAdmin) {
                    var linkText = app.lang.get('LBL_DASHLET_FORECAST_CONFIG_LINK_TEXT', 'Forecasts');
                    msg += '  <a href="#Forecasts/config">' + linkText + '</a>';
                }

                return msg;
            },
            /**
             * gets window location parameters by name regardless of case
             * @param {String} name name of parameter being searched for
             * @param {String} queryString
             * @returns {String}
             */
            getWindowLocationParameterByName: function (name, queryString) {
                name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
                var regex = new RegExp('[\\?&]' + name + '=([^&#]*)', 'g'),
                    matchResults = queryString.match(regex);
                if (matchResults && matchResults.length > 0) {
                    var results = regex.exec(matchResults[matchResults.length - 1]);
                }
                return (results === undefined || results === null) ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
            },

            /**
             * Javascript equivalent to the Sugar `isTruthy` utility function.
             *
             * @param {string|boolean} value The value to test.
             * @return {boolean} `true` if the value to test is roughly
             *   equivalent to `true` (in a Sugar context).
             */
            isTruthy: function(value) {
                if (_.isString(value)) {
                    value = value.toLowerCase();
                }
                return value === true
                    || value === 'true'
                    || value === 1
                    || value === '1'
                    || value === 'on'
                    || value === 'yes';
            }
        });
    });
})(SUGAR.App);

/* End of File include/javascript/sugar7/utils.js */

/*
     * Your installation or use of this SugarCRM file is subject to the applicable
     * terms available at
     * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
     * If you do not agree to all of the applicable terms or do not have the
     * authority to bind the entity as an authorized representative, then do not
     * install or use this SugarCRM file.
     *
     * Copyright (C) SugarCRM Inc. All rights reserved.
     *//*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('app:init', function() {

        app.utils = _.extend(app.utils, {

            'FilterOptions': Backbone.Model.extend({

                /**
                 * @inheritDoc
                 */
                initialize: function(options) {
                    this._filterPopulateNames = [];
                    this._filterRelate = null;
                },

                /**
                 * Sets relate fields.
                 *
                 * @param {Object} value The list of fields.
                 * @chainable
                 */
                setFilterRelate: function(value) {
                    if (!_.isObject(value) || _.isEmpty(value)) {
                        return this;
                    }
                    this._filterRelate = value;
                    this.set('stickiness', false);
                    return this;
                },

                /**
                 * Sets populate filter hash.
                 *
                 * @param {Object} hash The list of fields and their values.
                 * @chainable
                 */
                setFilterPopulate: function(value) {
                    if (!_.isObject(value) || _.isEmpty(value)) {
                        return this;
                    }
                    this.set('filter_populate', value);
                    this.set('stickiness', false);
                    return this;
                },

                /**
                 * Sets initial filter id.
                 *
                 * @param {String} id The id of the initial filter.
                 * @chainable
                 */
                setInitialFilter: function(id) {
                    this.set('initial_filter', id);
                    return this;
                },

                /**
                 * Sets initial filter name.
                 *
                 * @param {String} name The name of the initial filter.
                 * @chainable
                 */
                setInitialFilterLabel: function(name) {
                    this.set('initial_filter_label', name);
                    return this;
                },

                /**
                 * Sets the list of modules from which to look up the initial
                 * filter label string.
                 *
                 * @param {String[]} modules The list of modules.
                 */
                setLangModules: function(modules) {
                    if (!_.isArray(modules)) {
                        return;
                    }
                    this.set('initial_filter_lang_modules', modules);
                },

                /**
                 * Sets filter name based on values of populate fields.
                 *
                 * @chainable
                 */
                relateInitialFilterLabel: function() {
                    this.set('initial_filter_label', this._filterPopulateNames.join(', '));
                    return this;
                },

                /**
                 * Initializes filter options.
                 *
                 * @param {Object} options The list of fields.
                 * @chainable
                 */
                config: function(options) {
                    options = options || {};
                    this.setInitialFilter(options.initial_filter);
                    this.setInitialFilterLabel(options.initial_filter_label);
                    this.setFilterPopulate(options.filter_populate);
                    this.setFilterRelate(options.filter_relate);
                    return this;
                },

                /**
                 * Populates `filter_populate` with relate fields' values.
                 *
                 * @param {Backbone.Model} relateModel The related model.
                 * @chainable
                 */
                populateRelate: function(relateModel) {
                    if (_.isEmpty(this._filterRelate)) {
                        return this;
                    }
                    var filterPopulate = this.get('filter_populate') || {};
                    _.each(this._filterRelate, function(toField, fromField) {
                        filterPopulate[toField] = relateModel.get(fromField);

                        var relateNameField = _.find(relateModel.fields, function(field) {
                            return field.id_name === fromField;
                        });
                        if (relateNameField) {
                            this._filterPopulateNames.push(relateModel.get(relateNameField.name));
                        }
                    }, this);
                    this.set('filter_populate', filterPopulate);

                    if (!this.get('initial_filter_label')) {
                        this.relateInitialFilterLabel();
                    }
                    return this;
                },

                /**
                 * Outputs the filter options.
                 *
                 * @return {Object/undefined} The hash of filter options.
                 */
                format: function() {
                    if (!this.get('initial_filter') || !this.get('filter_populate')) {
                        return;
                    }
                    return this.toJSON();
                }
            })
        });
    });
})(SUGAR.App);

/* End of File include/javascript/sugar7/utils-filters.js */

/*
     * Your installation or use of this SugarCRM file is subject to the applicable
     * terms available at
     * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
     * If you do not agree to all of the applicable terms or do not have the
     * authority to bind the entity as an authorized representative, then do not
     * install or use this SugarCRM file.
     *
     * Copyright (C) SugarCRM Inc. All rights reserved.
     *//*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

(function (app) {

    /**
     * Field widgets to use Required labels with because they don't use select or input fields
     * @private
     */
    var _useRequiredLabels = {
        /**
         * It's nonsensical to make a bool field required since it is always has a value (TRUE or FALSE),
         * but it's possible to define it as required in vardefs.
         */
        "bool": true,
        /**
         * Only really needed on edit template where we use radio buttons.
         * For list-edit template, we don't use radio buttons but select2 widget.
         */
        "radioenum": 'edit'
    };

    app.events.on("app:init", function () {

        var _fieldProto = _.clone(app.view.Field.prototype);
        _.extend(app.view.Field.prototype, {

            /**
             * Hides help information (`def.help`) on edit views if set to
             * `true`. This is metadata driven.
             */
            hideHelp: false,

            /**
             * Template for the exclamation mark icon added when decorating errors
             */
            exclamationMarkTemplate: Handlebars.compile(
                '<span class="error-tooltip add-on" data-container="body" rel="tooltip" title="{{arrayJoin this ", "}}"><i class="fa fa-exclamation-circle"></i></span>'
            ),

            /**
             * Handle validation errors
             * Set to edit mode and decorates the field
             * @param {Object} errors The validation error(s) affecting this field
             */
            handleValidationError: function (errors) {
                this.clearErrorDecoration();
                _.defer(function (field) {
                    field._errors = errors;
                    field.parent ? field.parent.setMode('edit') : field.setMode('edit');

                    // As we're now "post form submission", if `no_required_placeholder`, we need to
                    // manually decorateRequired (as we only omit required on form's initial render)
                    if (!field._shouldRenderRequiredPlaceholder()) {
                        field.decorateRequired();
                    }

                    // handle view specific validation error considerations
                    if (field.view && field.view.trigger) {
                        field.view.trigger('field:error', field, true);
                    }
                }, this);

                this.$el.off("keydown.record");
                $(document).off("mousedown.record" + this.name);
            },

            /**
             * Resets the properties that are put on the field by
             * {@link #handleValidationError}.
             */
            removeValidationErrors: function() {
                this._errors = {};
            },

            /**
             * Remove the old view's css class (e.g. detail, edit)
             * currently maps the action directly to the css class name
             * but may be overridden in the future.
             *
             * @param {String} action the name of the action to remove
             * @protected
             */
            _removeViewClass: function (action) {
                // in case our getFieldElement has been overridden, use this.$el directly
                this.$el.removeClass(action);
            },

            /**
             * Add the new view's css class (e.g. detail, edit)
             * currently maps the action directly to the css class name
             * but may be overridden in the future.
             *
             * @param {String} action the name of the action to remove
             * @protected
             */
            _addViewClass: function (action) {
                // in case our getFieldElement has been overridden, use this.$el directly
                this.$el.addClass(action);
            },

            /**
             * Returns true if it's readonly, had access to read the field and has no data.
             *
             * Override this function for special logic or property to
             * determine nodata property.
             *
             * You can also specify that a certain field doesn't support
             * `showNoData` or always return either `true` or `false`.
             * Example for controller with `showNoData` always set to false:
             * <pre><code>
             * ({
             *     showNoData: false,
             *     // ...
             *     initialize: function(options) {
             *     // ...
             * })
             * </code></pre>
             *
             * @return {Boolean} `true` if it is readonly and it has no data
             * otherwise `false`.
             */
            showNoData: function() {
                return this.def.readonly && app.acl.hasAccessToModel('readonly', this.model, this.name) && this.name && !this.model.has(this.name);
            },

            /**
             * {@inheritDoc}
             * Checks fallback actions first and then follows ACLs checking
             * after that.
             *
             * First, check whether the action belongs to the fallback actions
             * and no more chaining fallback map.
             * Second, the field should fallback to 'nodata' if current field
             * requires to display nodata.
             * Finally, checks ACLs to see if the current user has access to
             * action.
             *
             * @param {String} action name.
             * @return {Boolean} true if accessable otherwise false.
             */
            _checkAccessToAction: function(action) {

                if (_.contains(this.fallbackActions, action) && _.isUndefined(this.viewFallbackMap[action])) {
                    return true;
                }

                if (_.result(this, 'showNoData') === true) {
                    return action === 'nodata';
                }

                return app.acl.hasAccessToModel(action, this.model, this.name);
            },

            /**
             * Defines fallback rules for ACL checking.
             */
            viewFallbackMap: {
                'list': 'detail',
                'edit': 'detail',
                'detail': 'noaccess',
                'noaccess' : 'nodata'
            },
            /**
             * List of view names that directly fallback to base template
             * instead of 'detail'.
             */
            fallbackActions: [
                'noaccess', 'nodata'
            ],

            /**
             * {@inheritdoc}
             */
            _getFallbackTemplate: function(viewName) {
                if (_.contains(this.fallbackActions, viewName)) {
                    return viewName;
                }
                return (this.isDisabled() && viewName === 'disabled') ? 'edit' :
                    (this.view.fallbackFieldTemplate || 'detail');
            },
            /**
             * Override _render to redecorate fields if field is on error state
             * and to add view action CSS class.
             */
            _render: function () {
                this.clearErrorDecoration();
                this._processHelp();

                _fieldProto._render.call(this);

                // handle rendering the action class if disabled
                if (this._previousAction) {
                    this._addViewClass(this._previousAction);
                }
                this._addViewClass(this.action);
                if (!_.isEmpty(this._errors)) {
                    if (this.action === 'edit') {
                        this.decorateError(this._errors);
                    }
                }
                if (this.def.required) {
                    this.clearRequiredLabel();
                    if ((this.action === 'edit' || -1 !== _.indexOf(['edit', 'list-edit'], this.tplName)) && this._shouldRenderRequiredPlaceholder()) {
                        this.decorateRequired();
                    }
                }
                if (this.def.help) {
                    this.clearHelper();
                    if (this.action === 'edit' || -1 !== _.indexOf(['edit', 'list-edit'], this.tplName)) {
                        this.decorateHelper();
                    }
                }

                /**
                 * Fix placeholder on global search on IE and old browsers
                 */
                if ($.fn.placeholder) {
                    var $input = this.$('input');
                    _.each($input, function(element) {
                        var $element = $(element);
                        $element.attr('placeholder') && $element.placeholder();
                    });
                }
            },

            /**
             * Help information block visibility is metadata driven
             * (`hide_help`).
             *
             * By default (if no metadata is defined) we show help block on
             * edit templates except on list views (will be hidden).
             * Currently there is no templates using this help block on detail
             * templates, but we make sure we only affect the edit view.
             *
             * @protected
             */
            _processHelp: function() {

                if (this.meta && !_.isUndefined(this.meta['hide_help'])) {
                    this.hideHelp = !!this.meta['hide_help'];
                    return;
                }

                if (this.view.action === 'list' && this.action === 'edit') {
                    this.hideHelp = true;
                }
            },

            /**
             * Remove helper tooltip
             */
            clearHelper: function() {
                this.$el.closest('.record-cell').attr({
                    'rel': ''
                });
            },
            /**
             * Default implementation for field helper
             */
            decorateHelper: function() {
                this.$el.closest('.record-cell').attr({
                    'rel': 'tooltip',
                    'data-title': this.def['help'],
                    'data-placement': 'bottom'
                });
            },
            /**
             * Helper to determine if we should call decorateRequired. Primarily for pages like Login
             * where we don't want to have (Required) in the placeholder on initial render. This gets
             * called on `this._render`. Since we DO want required in placeholder "post submission" we
             * check this again in `this.handleValidationError` and manually add back (Required) if set.
             *
             * @return {Boolean} Whether we should attempt to render required placeholder or not
             */
            _shouldRenderRequiredPlaceholder: function () {
                return !this.def.no_required_placeholder;
            },

            /**
             * Default implementation of Required decoration
             */
            decorateRequired: function () {
                var useLabels = _useRequiredLabels[this.type];
                useLabels = _.isString(useLabels) ? (useLabels === this.tplName) : useLabels;
                if (useLabels) {
                    this.setRequiredLabel();
                } else {
                    // Most fields use Placeholder
                    this.setRequiredPlaceholder();
                }

            },

            /**
             * Sets the required placeholder on field tag.
             *
             * If no element is provided, sets it on the first existing
             * `this.fieldTag`.
             * The required placeholder text is defined by `LBL_REQUIRED_FIELD`
             * label.
             * If an existing placeholder exists, prefixes with
             * `(LBL_REQUIRED_FIELD) ` and leaves the rest untouched.
             *
             * @param {HTMLElement} [elem] Element to attach the placeholder
             *   which defaults to first `this.fieldTag` available in this
             *   field.
             */
            setRequiredPlaceholder: function(el) {
                var label = app.lang.get('LBL_REQUIRED_FIELD', this.module),
                    placeholder;

                el = el || this.$(this.fieldTag).first();
                placeholder = el.attr('placeholder');
                placeholder = (placeholder) ? '(' + label + ') ' + placeholder : label;
                el.attr('placeholder', placeholder.trim()).addClass('required');
            },

            /**
             * Add Required label to field's label for fields that don't support placeholders
             * @param element (Optional) any element that is enclosed by field's record-cell
             */
            setRequiredLabel: function (element) {
                var ele = element || this.$el;
                var $label = ele.closest('.record-cell').find(".record-label");
                $label.append(' <span data-required="required">(' + app.lang.get("LBL_REQUIRED_FIELD", this.module) + ')</span>');
            },

            /**
             * Remove default Required label from field labels
             * @param element (Optional) any element that is enclosed by field's record-cell
             */
            clearRequiredLabel: function (element) {
                var ele = element || this.$el;
                var $label = ele.closest('.record-cell').find('span[data-required]');
                $label.remove();
            },

            /**
             * {@inheritdoc}
             *
             * Override setMode to remove any stale view action CSS classes.
             * @override
             */
            setMode: function (name) {
                // if we are disabled, we want to remove the previous view action, not the disabled class
                var oldAction = this._previousAction || this.action;
                this._removeViewClass(oldAction);

                _fieldProto.setMode.call(this, name);
            },

            /**
             * {@inheritdoc}
             *
             * Override setMode to remove the stale disabled CSS class.
             * @override
             */
            setDisabled: function (disable) {

                if (!this._checkAccessToAction('disabled')) {
                    return;
                }

                disable = _.isUndefined(disable) ? true : disable;

                // remove the stale disabled CSS class (this.action === 'disabled')
                if (disable === false && this.isDisabled()) {
                    this._removeViewClass(this.action);
                }
                _fieldProto.setDisabled.call(this, disable);
            },
            /**
             * Decorate error gets called when this Field has a validation error.  This function applies custom error
             * styling appropriate for this field.
             * The field is put into 'edit' mode prior to this this being called.
             *
             * Fields should override/implement this when they need to provide custom error styling for different field
             * types (like e-mail, etc).  You can also override clearErrorDecoration.
             *
             * @param {Object} errors The validation error(s) affecting this field
             */
            decorateError: function (errors) {
                var ftag = this.fieldTag || '',
                    $ftag = this.$(ftag),
                    errorMessages = [],
                    $tooltip;

                // Add error styling
                this.$el.closest('.record-cell').addClass('error');
                this.$el.addClass('error');
                if(_.isString(errors)){
                    // A custom validation error was triggered for this field
                    errorMessages.push(errors);
                } else {
                    // For each error add to error help block
                    _.each(errors, function (errorContext, errorName) {
                        errorMessages.push(app.error.getErrorString(errorName, errorContext));
                    });
                }

                // FIXME: un-needed extra div wrapping the field should be
                // removed when SC-2568 gets in, for the time being it is only
                // used on non datetime fields
                var isWrapped = $ftag.parent().hasClass('input-append');
                if (!isWrapped) {
                    $ftag.wrap('<div class="input-append error ' + ftag + '">');
                } else {
                    $ftag.parent().addClass('error');
                }

                $tooltip = $(this.exclamationMarkTemplate(errorMessages));
                $ftag.after($tooltip);
                this.createErrorTooltips($tooltip);
            },

            /**
             * Create error tooltips.
             * @param {jQuery} $element
             */
            createErrorTooltips: function($element) {
                this._errorTooltips = this._errorTooltips || [];
                this._errorTooltips.push(app.utils.tooltip.initialize($element));
            },

            /**
             * Destroy all error tooltips.
             */
            destroyAllErrorTooltips: function() {
                app.utils.tooltip.destroy(this._errorTooltips);
                this._errorTooltips = null;
            },

            /**
             * Destroy all error tooltips before disposing the field.
             * @private
             */
            _dispose: function() {
                this.destroyAllErrorTooltips();
                _fieldProto._dispose.call(this);
            },

            /**
             * Remove error decoration from field if it exists.
             */
            clearErrorDecoration: function () {
                var ftag = this.fieldTag || '',
                    $ftag = this.$(ftag);

                // Remove previous exclamation then add back.
                this.destroyAllErrorTooltips();
                this.$('.add-on.error-tooltip').remove();
                var isWrapped = $ftag.parent().hasClass('input-append');

                // FIXME: this check for datetime should be made generic (when
                // SC-2568 gets in) based on use of normal addon
                var isDateField = $ftag.parent().hasClass('date');
                if (isDateField) {
                    $ftag.parent().removeClass('error');
                } else if (isWrapped) {
                    $ftag.unwrap();
                }

                this.$el.removeClass(ftag);
                this.$el.removeClass("error");
                this.$el.closest('.record-cell').removeClass("error");

                if (this.view && this.view.trigger) {
                    this.view.trigger('field:error', this, false);
                }
            },

            /**
             * Adding additional events for links with bad `href` attribute
             * @param {Array} events Events for the field
             */
            delegateEvents: function(events) {
                events = events || this.events || (this.def ? this.def.events : null);
                if (!events) {
                    return;
                }
                events['click a[href="javascript:void(0)"]'] = '_handleBadLinkHref';
                events['click a[href="javascript:void(0);"]'] = '_handleBadLinkHref';
                _fieldProto.delegateEvents.call(this, events);
            },

            /**
             * {@inheritDoc}
             * Attach focus handler in order to pass the current element's location.
             */
            bindDomChange: function() {
                this.$(this.fieldTag).on('focus', _.bind(this.handleFocus, this));
                _fieldProto.bindDomChange.call(this);
            },

            /**
             * {@inheritDoc}
             * Calculate current offset location and pass it to the parent's view.
             */
            handleFocus: function(evt) {
                if (this.disposed) {
                    return;
                }
                var left = this.$el.offset().left,
                    right = this.$el.outerWidth() + left,
                    top = this.$el.offset().top,
                    bottom = this.$el.outerHeight() + top;
                this.view.trigger('field:focus:location', {
                    left: left,
                    right: right,
                    top: top,
                    bottom: bottom
                });
            },

            /**
             * Handle click event for bad links
             * @param {Object} evt Click event
             * @private
             */
            _handleBadLinkHref: function(evt) {
                evt.preventDefault();
            }
        });
    });

})(SUGAR.App);

/* End of File include/javascript/sugar7/field.js */

/*
     * Your installation or use of this SugarCRM file is subject to the applicable
     * terms available at
     * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
     * If you do not agree to all of the applicable terms or do not have the
     * authority to bind the entity as an authorized representative, then do not
     * install or use this SugarCRM file.
     *
     * Copyright (C) SugarCRM Inc. All rights reserved.
     *//*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    var _oldMetadataSet = app.metadata.set;
    /**
     * Hack the metadata to fix teamset type
     * @param data
     */
    app.metadata.set = function(data){
        _.each(data.modules, function(module){
            if (!_.isUndefined(module.fields)) {
                var field = module.fields.team_name;
                if (field) {
                    delete field.len;
                    field.type = "teamset";
                }

                _.each(module.fields,function(field) {
                    // Metadata is invalid for relate fields like "account_id"
                    // In certain cases, their type is "relate" and source is "non-db"
                    // See bug 60632
                    if  (field.name &&
                        (field.type === "relate") &&
                        // ends with "_id"
                        (field.name.length > 2 &&
                            (field.name.length -
                             field.name.lastIndexOf("_id")) === 3))
                    {
                        field.type = "id";
                        delete field.source;
                    }
                });
            }
        }, this);
        _oldMetadataSet.apply(this, arguments);
    };
})(SUGAR.App);

// Hack to workaround latest select2 chrome "Oh Snap" crashes
// Tracked here: SP-805
// https://codereview.chromium.org/14060024
// https://github.com/ivaynberg/select2/issues/1099
// TODO: We need to remove this when fix is pushed to stable chrome released
WebKitMutationObserver = function() {};
WebKitMutationObserver.prototype.observe = function() {};

/* End of File include/javascript/sugar7/hacks.js */

/*
     * Your installation or use of this SugarCRM file is subject to the applicable
     * terms available at
     * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
     * If you do not agree to all of the applicable terms or do not have the
     * authority to bind the entity as an authorized representative, then do not
     * install or use this SugarCRM file.
     *
     * Copyright (C) SugarCRM Inc. All rights reserved.
     *//*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {

    /**
     * This file handles the alerts for the sidecar sync events
     *
     * Sidecar provides 5 events on which we will display/dismiss alerts:
     *
     *  - app:sync indicates the beginning of app.sync()
     *  - app:sync:complete indicates app.sync() has finished without errors
     *  - app:sync:error indicates app.sync() has finished with errors
     *  - data:sync:start indicates we are synchronizing a Bean or BeanCollection (fetch/save/destroy)
     *  - data:sync:complete indicates the Bean or BeanCollection sync has finished successfully or not
     */

    /**
     * On 'app:sync' we display a simple 'LBL_LOADING' process alert
     */
    app.events.on('app:sync', function() {
        app.alert.show('app:sync', {level: 'process', title: app.lang.get('LBL_LOADING')});
    });

    /**
     * On 'app:sync:complete' and 'app:sync:error' we dismiss the alert
     */
    app.events.on('app:sync:complete app:sync:error', function() {
        app.alert.dismiss('app:sync');
    });


    /**
     * Override Context.loadData to attach showAlerts flag if it's the primary context.
     * While loading data of the primary context  we will display a processing message.
     *
     * @param options
     */
    var _contextProto = _.clone(app.Context.prototype);
    app.Context.prototype.loadData = function(options) {
        if (!this.parent) {
            options = options || {};
            options.showAlerts = true;
        }
        _contextProto.loadData.call(this, options);
    };

    /**
     * By default, on 'data:sync:start' we DON'T display a process alert
     *
     * You can pass options.showAlerts = true to your requests to enable the alert messages.
     *
     *      var bean = app.data.createBean('Accounts')
     *      bean.fetch({
     *          showAlerts: true
     *      });
     *
     * You can also override the alert options (including the title and messages) by passing an object 'showAlerts'
     * such as:
     *
     *      var bean = app.data.createBean('Accounts')
     *      bean.save(null, {
     *          showAlerts: {
     *              'process' : {
     *                  'level' : 'warning',
     *                  'title' : 'Saving...',
     *                  'messages' : 'This request takes a few minutes'
     *              },
     *              'success' : {
     *                  'messages' : 'Enjoy the data. '
     *              }
     *          }
     *      });
     *
     *  You may want to display only the success alert
     *
     *      bean.save(null, {
     *          showAlerts: {
     *              'process' : false,
     *              'success' : {
     *                  'read' : {
     *                      'messages' : 'Enjoy the data. '
     *                  }
     *              }
     *          }
     *      });
     */
    var processAlert = {
        _count: 0,

        dismiss: function() {
            this._count--;

            // Dismiss only if it's the last one
            if (this._count < 1) {
                this._count = 0;
                app.alert.dismiss('data:sync:process');
            }
        },

        show: function(options) {
            this._count++;
            app.alert.show('data:sync:process', options);
        }
    } ;

    app.events.on('data:sync:start', function(method, model, options) {

        options = options || {};

        // By default we don't display the alert
        if (!options.showAlerts) {
            return;
        }

        // The user can have disabled only the process alert
        if (options.showAlerts.process === false) {
            return;
        }

        // From here we are sure we want to show the process alert
        var alertOpts = {
            level: 'process'
        };

        // Pull labels for each method
        if (method === 'read') {
            alertOpts.title = app.lang.get('LBL_LOADING');
        }
        else if (method === 'delete') {
            // options.relate means we are breaking a relationship between two records, not actually deleting a record
            alertOpts.title = options.relate ?
                app.lang.get('LBL_UNLINKING') : app.lang.get('LBL_DELETING');
        }
        else {
            alertOpts.title = app.lang.get('LBL_SAVING');
        }

        // Check for an alert options object attach to options that would override
        if (_.isObject(options.showAlerts.process)) {
            _.extend(alertOpts, options.showAlerts.process);
        }

        // Show alert
        processAlert.show(alertOpts);
    });

    // Not to be confused with the event fired for data:sync:complete.
    var syncCompleteHandler = function(type, messages, method, model, options) {

        options = options || {};

        // Preconstruct the alert options.
        var alertOpts = {
            level: type,
            messages: messages
        };
        alertOpts.autoClose = (alertOpts.level === 'error') ? false : true;

        // By default we don't display the alert
        if (!options.showAlerts) return;

        // Error module will display proper message
        if (method === 'read') return;

        // The user can have disabled only this particular type of alert.
        if (options.showAlerts[type] === false) return;

        // Check for an alert options object attach to options
        if (_.isObject(options.showAlerts[type])) {
            _.extend(alertOpts, options.showAlerts[type]);
        }

        app.alert.show('data:sync:' + type, alertOpts);
    };

    app.events.on('data:sync:success', function(method, model, options) {
        var messages;

        if (method === 'delete') {
            // options.relate means we are breaking a relationship between two records, not actually deleting a record
            messages = options.relate ? 'LBL_UNLINKED' : 'LBL_DELETED';
        }
        else {
            messages = 'LBL_SAVED';
        }

        syncCompleteHandler('success', messages, method, model, options);
    });

    app.events.on('data:sync:error', function(method, model, options, error) {
        var suppressErrorMessageFor = [409, 412];

        if (!error || (!error.handled && _.indexOf(suppressErrorMessageFor, error.status) === -1)) {
            syncCompleteHandler('error', 'ERR_GENERIC_SERVER_ERROR', method, model, options);
        }
    });

    app.events.on('data:sync:complete', function(method, model, options) {
        // As we display alerts we have have to check if there is a process
        // alert to dismiss prior to display the success one (as many requests
        // can be fired at the same time we make sure not to dismiss another
        // process alert!)
        if (options.showAlerts && options.showAlerts.process !== false) {
            processAlert.dismiss();
        }
    });

})(SUGAR.App);

/* End of File include/javascript/sugar7/alert.js */

/*
     * Your installation or use of this SugarCRM file is subject to the applicable
     * terms available at
     * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
     * If you do not agree to all of the applicable terms or do not have the
     * authority to bind the entity as an authorized representative, then do not
     * install or use this SugarCRM file.
     *
     * Copyright (C) SugarCRM Inc. All rights reserved.
     *//*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Handlebars helpers.
 *
 * These functions are to be used in handlebars templates.
 * @class View.Handlebars.helpers
 * @singleton
 */
(function(app) {
    app.events.on("app:init", function() {

        /**
         * Gets the letters used for the icons shown in various headers for
         * each module, based on the translated singular module name.
         *
         * This does not always match the name of the module in the model,
         * e.g. "Product" maps to "Quoted Line Item".
         *
         * If the module has an icon string defined, use it, otherwise
         * fallback to the module's translated name.
         *
         * If there are spaces in the name, (e.g. Revenue Line Items or
         * Product Catalog), it takes the initials from the first two words,
         * instead of the first two letters (e.g. RL and PC, instead of Re
         * and Pr).
         *
         * @param {string} module Module to which the icon belongs.
         */
        Handlebars.registerHelper('moduleIconLabel', function(module) {
            return app.lang.getModuleIconLabel(module);
        });

        /**
         * Handlebar helper to get the Tooltip used for the icons shown in various headers for each module, based on the
         * translated singular module name.  This does not always match the name of the module in the model,
         * i. e. Product == Revenue Line Item
         * @param {String} module to which the icon belongs
         */
        Handlebars.registerHelper('moduleIconToolTip', function(module) {
            return app.lang.getModuleName(module);
        });

        /**
         * Handlebar helper to translate any dropdown values to have the appropriate labels
         * @param {String} value The value to be translated.
         * @param {String} key The dropdown list name.
         */
        Handlebars.registerHelper('getDDLabel', function(value, key) {
            return app.lang.getAppListStrings(key)[value] || value;
        });

        /**
         * Handlebar helper to retrieve a view template as a sub template
         * @param {String} key Key for the template to retrieve.
         * @param {Object} data Data to pass into the compiled template
         * @param {Object} options (optional) Optional parameters
         * @return {String} String Template
         */
        Handlebars.registerHelper('subViewTemplate', function(key, data, options) {
            var frame, template;

            template = app.template.getView(key, options.hash.module);

            // merge the hash variables into the frame so they can be added as
            // private @variables via the data option below
            frame = _.extend(Handlebars.createFrame(options.data || {}), options.hash);

            return template ? template(data, {data: frame}) : '';
        });

        /**
         * Handlebar helper to retrieve a field template as a sub template
         * @param {String} fieldName determines which field to use.
         * @param {String} view determines which template within the field to use.
         * @param {Object} data Data to pass into the compiled template
         * @param {Object} options (optional) Optional parameters
         * @return {String} String Template
         */
        Handlebars.registerHelper('subFieldTemplate', function(fieldName, view, data, options) {
            var frame, template;

            template = app.template.getField(fieldName, view, options.hash.module);

            // merge the hash variables into the frame so they can be added as
            // private @variables via the data option below
            frame = _.extend(Handlebars.createFrame(options.data || {}), options.hash);

            return template ? template(data, {data: frame}) : '';
        });

        /**
         * Handlebar helper to retrieve a layout template as a sub template
         * @param {String} key Key for the template to retrieve.
         * @param {Object} data Data to pass into the compiled template
         * @param {Object} options (optional) Optional parameters
         * @return {String} String Template
         */
        Handlebars.registerHelper('subLayoutTemplate', function(key, data, options) {
            var frame, template;

            template = app.template.getLayout(key, options.hash.module);

            // merge the hash variables into the frame so they can be added as
            // private @variables via the data option below
            frame = _.extend(Handlebars.createFrame(options.data || {}), options.hash);

            return template ? template(data, {data: frame}) : '';
        });

        /**
         * @method buildUrl
         * Builds an URL based on hashes sent on handlebars helper.
         *
         * Example:
         * <pre><code>
         * {{buildUrl url="path/to/my-static-file.svg"}}
         * </code></pre>
         *
         * @see Utils.Utils#buildUrl to know how we are building the url.
         *
         * @param {Object} options
         *   The hashes being sent by handlebars helper. Currently requires
         *   `options.hash.url` until we extend this to be used for image
         *   fields.
         * @return {String}
         *   The safely built url.
         */
        Handlebars.registerHelper('buildUrl', function(options) {
            return new Handlebars.SafeString(app.utils.buildUrl(options.hash.url));
        });
    });
})(SUGAR.App);

/* End of File include/javascript/sugar7/hbs-helpers.js */

/*
     * Your installation or use of this SugarCRM file is subject to the applicable
     * terms available at
     * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
     * If you do not agree to all of the applicable terms or do not have the
     * authority to bind the entity as an authorized representative, then do not
     * install or use this SugarCRM file.
     *
     * Copyright (C) SugarCRM Inc. All rights reserved.
     *//*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('app:init', function() {
        app.lang = _.extend(app.lang, {

            /**
             * Retrieves module singular from name.
             *
             * @deprecated Deprecated since 7.6.0. Use
             *   {@link Core.Language#getModuleName} instead. Will be removed
             *   in 7.8.0.
             * @param {String} module Module name.
             * @return {String} Module singular form.
             */
            getModuleSingular: function(module) {
                app.logger.warn('The `app.lang.getModuleSingular` function has been deprecated since 7.6.0. Please ' +
                    + 'upgrade your code to use `app.lang.getModuleName`.');

                var modString = app.metadata.getStrings('mod_strings')[module],
                    moduleSingular = (modString ? modString['LBL_MODULE_NAME_SINGULAR'] : '') ||
                        app.lang.getAppListStrings('moduleListSingular')[module] ||
                        app.lang.getAppListStrings('moduleList')[module] ||
                        module;

                return moduleSingular;
            },

            /**
             * Gets the letters used for the icons shown in various headers for
             * each module, based on the translated singular module name.
             *
             * This does not always match the name of the module in the model,
             * e.g. "Product" maps to "Quoted Line Item".
             *
             * If the module has an icon string defined, use it, otherwise
             * fallback to the module's translated name.
             *
             * If there are spaces in the name, (e.g. Revenue Line Items or
             * Product Catalog), it takes the initials from the first two words,
             * instead of the first two letters (e.g. RL and PC, instead of Re
             * and Pr).
             *
             * @param {string} module Module to which the icon belongs.
             */
            getModuleIconLabel: function(module) {
                var name = app.lang.getAppListStrings('moduleIconList')[module] ||
                        app.lang.getModuleName(module);
                var space = name.indexOf(' ');
                var hasSpace = space !== -1;
                var result;

                if (hasSpace) {
                    result = name.substring(0, 1) + name.substring(space + 1, space + 2);
                } else {
                    result = name.substring(0, 2);
                }

                return result;
            }
        });

    });

    /**
     * When application finishes syncing.
     */
    app.events.on('app:sync:complete', function() {
        app.date.lang(app.user.getPreference('language'));
    });

    app.events.on('lang:direction:change', function() {
        var direction = app.lang.direction,
            isRTL = direction === 'rtl';
        $('html').toggleClass('rtl', isRTL);
    });

})(SUGAR.App);

/* End of File include/javascript/sugar7/language.js */

